{"ast":null,"code":"'use strict';\n\nmodule.exports = StackUtils;\n\nfunction StackUtils(opts) {\n  if (!(this instanceof StackUtils)) {\n    throw new Error('StackUtils constructor must be called with new');\n  }\n\n  opts = opts || {};\n  this._cwd = (opts.cwd || process.cwd()).replace(/\\\\/g, '/');\n  this._internals = opts.internals || [];\n  this._wrapCallSite = opts.wrapCallSite || false;\n}\n\nmodule.exports.nodeInternals = nodeInternals;\n\nfunction nodeInternals() {\n  if (!module.exports.natives) {\n    module.exports.natives = Object.keys(process.binding('natives'));\n    module.exports.natives.push('bootstrap_node', 'node', 'internal/bootstrap/node');\n  }\n\n  return module.exports.natives.map(function (n) {\n    return new RegExp('\\\\(' + n + '\\\\.js:\\\\d+:\\\\d+\\\\)$');\n  }).concat([/\\s*at (bootstrap_)?node\\.js:\\d+:\\d+?$/, /\\(internal\\/[^:]+:\\d+:\\d+\\)$/, /\\/\\.node-spawn-wrap-\\w+-\\w+\\/node:\\d+:\\d+\\)?$/]);\n}\n\nStackUtils.prototype.clean = function (stack) {\n  if (!Array.isArray(stack)) {\n    stack = stack.split('\\n');\n  }\n\n  if (!/^\\s*at /.test(stack[0]) && /^\\s*at /.test(stack[1])) {\n    stack = stack.slice(1);\n  }\n\n  var outdent = false;\n  var lastNonAtLine = null;\n  var result = [];\n  stack.forEach(function (st) {\n    st = st.replace(/\\\\/g, '/');\n\n    var isInternal = this._internals.some(function (internal) {\n      return internal.test(st);\n    });\n\n    if (isInternal) {\n      return null;\n    }\n\n    var isAtLine = /^\\s*at /.test(st);\n\n    if (outdent) {\n      st = st.replace(/\\s+$/, '').replace(/^(\\s+)at /, '$1');\n    } else {\n      st = st.trim();\n\n      if (isAtLine) {\n        st = st.substring(3);\n      }\n    }\n\n    st = st.replace(this._cwd + '/', '');\n\n    if (st) {\n      if (isAtLine) {\n        if (lastNonAtLine) {\n          result.push(lastNonAtLine);\n          lastNonAtLine = null;\n        }\n\n        result.push(st);\n      } else {\n        outdent = true;\n        lastNonAtLine = st;\n      }\n    }\n  }, this);\n  stack = result.join('\\n').trim();\n\n  if (stack) {\n    return stack + '\\n';\n  }\n\n  return '';\n};\n\nStackUtils.prototype.captureString = function (limit, fn) {\n  if (typeof limit === 'function') {\n    fn = limit;\n    limit = Infinity;\n  }\n\n  if (!fn) {\n    fn = this.captureString;\n  }\n\n  var limitBefore = Error.stackTraceLimit;\n\n  if (limit) {\n    Error.stackTraceLimit = limit;\n  }\n\n  var obj = {};\n  Error.captureStackTrace(obj, fn);\n  var stack = obj.stack;\n  Error.stackTraceLimit = limitBefore;\n  return this.clean(stack);\n};\n\nStackUtils.prototype.capture = function (limit, fn) {\n  if (typeof limit === 'function') {\n    fn = limit;\n    limit = Infinity;\n  }\n\n  if (!fn) {\n    fn = this.capture;\n  }\n\n  var prepBefore = Error.prepareStackTrace;\n  var limitBefore = Error.stackTraceLimit;\n  var wrapCallSite = this._wrapCallSite;\n\n  Error.prepareStackTrace = function (obj, site) {\n    if (wrapCallSite) {\n      return site.map(wrapCallSite);\n    }\n\n    return site;\n  };\n\n  if (limit) {\n    Error.stackTraceLimit = limit;\n  }\n\n  var obj = {};\n  Error.captureStackTrace(obj, fn);\n  var stack = obj.stack;\n  Error.prepareStackTrace = prepBefore;\n  Error.stackTraceLimit = limitBefore;\n  return stack;\n};\n\nStackUtils.prototype.at = function at(fn) {\n  if (!fn) {\n    fn = at;\n  }\n\n  var site = this.capture(1, fn)[0];\n\n  if (!site) {\n    return {};\n  }\n\n  var res = {\n    line: site.getLineNumber(),\n    column: site.getColumnNumber()\n  };\n\n  this._setFile(res, site.getFileName());\n\n  if (site.isConstructor()) {\n    res.constructor = true;\n  }\n\n  if (site.isEval()) {\n    res.evalOrigin = site.getEvalOrigin();\n  } // Node v10 stopped with the isNative() on callsites, apparently\n\n  /* istanbul ignore next */\n\n\n  if (site.isNative()) {\n    res.native = true;\n  }\n\n  var typename = null;\n\n  try {\n    typename = site.getTypeName();\n  } catch (er) {}\n\n  if (typename && typename !== 'Object' && typename !== '[object Object]') {\n    res.type = typename;\n  }\n\n  var fname = site.getFunctionName();\n\n  if (fname) {\n    res.function = fname;\n  }\n\n  var meth = site.getMethodName();\n\n  if (meth && fname !== meth) {\n    res.method = meth;\n  }\n\n  return res;\n};\n\nStackUtils.prototype._setFile = function (result, filename) {\n  if (filename) {\n    filename = filename.replace(/\\\\/g, '/');\n\n    if (filename.indexOf(this._cwd + '/') === 0) {\n      filename = filename.substr(this._cwd.length + 1);\n    }\n\n    result.file = filename;\n  }\n};\n\nvar re = new RegExp('^' + // Sometimes we strip out the '    at' because it's noisy\n'(?:\\\\s*at )?' + // $1 = ctor if 'new'\n'(?:(new) )?' + // $2 = function name (can be literally anything)\n// May contain method at the end as [as xyz]\n'(?:(.*?) \\\\()?' + // (eval at <anonymous> (file.js:1:1),\n// $3 = eval origin\n// $4:$5:$6 are eval file/line/col, but not normally reported\n'(?:eval at ([^ ]+) \\\\((.+?):(\\\\d+):(\\\\d+)\\\\), )?' + // file:line:col\n// $7:$8:$9\n// $10 = 'native' if native\n'(?:(.+?):(\\\\d+):(\\\\d+)|(native))' + // maybe close the paren, then end\n// if $11 is ), then we only allow balanced parens in the filename\n// any imbalance is placed on the fname.  This is a heuristic, and\n// bound to be incorrect in some edge cases.  The bet is that\n// having weird characters in method names is more common than\n// having weird characters in filenames, which seems reasonable.\n'(\\\\)?)$');\nvar methodRe = /^(.*?) \\[as (.*?)\\]$/;\n\nStackUtils.prototype.parseLine = function parseLine(line) {\n  var match = line && line.match(re);\n\n  if (!match) {\n    return null;\n  }\n\n  var ctor = match[1] === 'new';\n  var fname = match[2];\n  var evalOrigin = match[3];\n  var evalFile = match[4];\n  var evalLine = Number(match[5]);\n  var evalCol = Number(match[6]);\n  var file = match[7];\n  var lnum = match[8];\n  var col = match[9];\n  var native = match[10] === 'native';\n  var closeParen = match[11] === ')';\n  var res = {};\n\n  if (lnum) {\n    res.line = Number(lnum);\n  }\n\n  if (col) {\n    res.column = Number(col);\n  }\n\n  if (closeParen && file) {\n    // make sure parens are balanced\n    // if we have a file like \"asdf) [as foo] (xyz.js\", then odds are\n    // that the fname should be += \" (asdf) [as foo]\" and the file\n    // should be just \"xyz.js\"\n    // walk backwards from the end to find the last unbalanced (\n    var closes = 0;\n\n    for (var i = file.length - 1; i > 0; i--) {\n      if (file.charAt(i) === ')') {\n        closes++;\n      } else if (file.charAt(i) === '(' && file.charAt(i - 1) === ' ') {\n        closes--;\n\n        if (closes === -1 && file.charAt(i - 1) === ' ') {\n          var before = file.substr(0, i - 1);\n          var after = file.substr(i + 1);\n          file = after;\n          fname += ' (' + before;\n          break;\n        }\n      }\n    }\n  }\n\n  if (fname) {\n    var methodMatch = fname.match(methodRe);\n\n    if (methodMatch) {\n      fname = methodMatch[1];\n      var meth = methodMatch[2];\n    }\n  }\n\n  this._setFile(res, file);\n\n  if (ctor) {\n    res.constructor = true;\n  }\n\n  if (evalOrigin) {\n    res.evalOrigin = evalOrigin;\n    res.evalLine = evalLine;\n    res.evalColumn = evalCol;\n    res.evalFile = evalFile && evalFile.replace(/\\\\/g, '/');\n  }\n\n  if (native) {\n    res.native = true;\n  }\n\n  if (fname) {\n    res.function = fname;\n  }\n\n  if (meth && fname !== meth) {\n    res.method = meth;\n  }\n\n  return res;\n};\n\nvar bound = new StackUtils();\nObject.keys(StackUtils.prototype).forEach(function (key) {\n  StackUtils[key] = bound[key].bind(bound);\n});","map":{"version":3,"sources":["D:/ReactJs/my-app5/node_modules/stack-utils/index.js"],"names":["module","exports","StackUtils","opts","Error","_cwd","cwd","process","replace","_internals","internals","_wrapCallSite","wrapCallSite","nodeInternals","natives","Object","keys","binding","push","map","n","RegExp","concat","prototype","clean","stack","Array","isArray","split","test","slice","outdent","lastNonAtLine","result","forEach","st","isInternal","some","internal","isAtLine","trim","substring","join","captureString","limit","fn","Infinity","limitBefore","stackTraceLimit","obj","captureStackTrace","capture","prepBefore","prepareStackTrace","site","at","res","line","getLineNumber","column","getColumnNumber","_setFile","getFileName","isConstructor","constructor","isEval","evalOrigin","getEvalOrigin","isNative","native","typename","getTypeName","er","type","fname","getFunctionName","function","meth","getMethodName","method","filename","indexOf","substr","length","file","re","methodRe","parseLine","match","ctor","evalFile","evalLine","Number","evalCol","lnum","col","closeParen","closes","i","charAt","before","after","methodMatch","evalColumn","bound","key","bind"],"mappings":"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","sourcesContent":["'use strict';\nmodule.exports = StackUtils;\n\nfunction StackUtils(opts) {\n  if (!(this instanceof StackUtils)) {\n    throw new Error('StackUtils constructor must be called with new');\n  }\n  opts = opts || {};\n  this._cwd = (opts.cwd || process.cwd()).replace(/\\\\/g, '/');\n  this._internals = opts.internals || [];\n  this._wrapCallSite = opts.wrapCallSite || false;\n}\n\nmodule.exports.nodeInternals = nodeInternals;\n\nfunction nodeInternals() {\n  if (!module.exports.natives) {\n    module.exports.natives = Object.keys(process.binding('natives'));\n    module.exports.natives.push('bootstrap_node', 'node',\n                                'internal/bootstrap/node');\n  }\n\n  return module.exports.natives.map(function (n) {\n    return new RegExp('\\\\(' + n + '\\\\.js:\\\\d+:\\\\d+\\\\)$');\n  }).concat([\n    /\\s*at (bootstrap_)?node\\.js:\\d+:\\d+?$/,\n    /\\(internal\\/[^:]+:\\d+:\\d+\\)$/,\n    /\\/\\.node-spawn-wrap-\\w+-\\w+\\/node:\\d+:\\d+\\)?$/\n  ]);\n}\n\nStackUtils.prototype.clean = function (stack) {\n  if (!Array.isArray(stack)) {\n    stack = stack.split('\\n');\n  }\n\n  if (!(/^\\s*at /.test(stack[0])) &&\n    (/^\\s*at /.test(stack[1]))) {\n    stack = stack.slice(1);\n  }\n\n  var outdent = false;\n  var lastNonAtLine = null;\n  var result = [];\n\n  stack.forEach(function (st) {\n    st = st.replace(/\\\\/g, '/');\n    var isInternal = this._internals.some(function (internal) {\n      return internal.test(st);\n    });\n\n    if (isInternal) {\n      return null;\n    }\n\n    var isAtLine = /^\\s*at /.test(st);\n\n    if (outdent) {\n      st = st.replace(/\\s+$/, '').replace(/^(\\s+)at /, '$1');\n    } else {\n      st = st.trim();\n      if (isAtLine) {\n        st = st.substring(3);\n      }\n    }\n\n    st = st.replace(this._cwd + '/', '');\n\n    if (st) {\n      if (isAtLine) {\n        if (lastNonAtLine) {\n          result.push(lastNonAtLine);\n          lastNonAtLine = null;\n        }\n        result.push(st);\n      } else {\n        outdent = true;\n        lastNonAtLine = st;\n      }\n    }\n  }, this);\n\n  stack = result.join('\\n').trim();\n\n  if (stack) {\n    return stack + '\\n';\n  }\n  return '';\n};\n\nStackUtils.prototype.captureString = function (limit, fn) {\n  if (typeof limit === 'function') {\n    fn = limit;\n    limit = Infinity;\n  }\n  if (!fn) {\n    fn = this.captureString;\n  }\n\n  var limitBefore = Error.stackTraceLimit;\n  if (limit) {\n    Error.stackTraceLimit = limit;\n  }\n\n  var obj = {};\n\n  Error.captureStackTrace(obj, fn);\n  var stack = obj.stack;\n  Error.stackTraceLimit = limitBefore;\n\n  return this.clean(stack);\n};\n\nStackUtils.prototype.capture = function (limit, fn) {\n  if (typeof limit === 'function') {\n    fn = limit;\n    limit = Infinity;\n  }\n  if (!fn) {\n    fn = this.capture;\n  }\n  var prepBefore = Error.prepareStackTrace;\n  var limitBefore = Error.stackTraceLimit;\n  var wrapCallSite = this._wrapCallSite;\n\n  Error.prepareStackTrace = function (obj, site) {\n    if (wrapCallSite) {\n      return site.map(wrapCallSite);\n    }\n    return site;\n  };\n\n  if (limit) {\n    Error.stackTraceLimit = limit;\n  }\n\n  var obj = {};\n  Error.captureStackTrace(obj, fn);\n  var stack = obj.stack;\n  Error.prepareStackTrace = prepBefore;\n  Error.stackTraceLimit = limitBefore;\n\n  return stack;\n};\n\nStackUtils.prototype.at = function at(fn) {\n  if (!fn) {\n    fn = at;\n  }\n\n  var site = this.capture(1, fn)[0];\n\n  if (!site) {\n    return {};\n  }\n\n  var res = {\n    line: site.getLineNumber(),\n    column: site.getColumnNumber()\n  };\n\n  this._setFile(res, site.getFileName());\n\n  if (site.isConstructor()) {\n    res.constructor = true;\n  }\n\n  if (site.isEval()) {\n    res.evalOrigin = site.getEvalOrigin();\n  }\n\n  // Node v10 stopped with the isNative() on callsites, apparently\n  /* istanbul ignore next */\n  if (site.isNative()) {\n    res.native = true;\n  }\n\n  var typename = null;\n  try {\n    typename = site.getTypeName();\n  } catch (er) {}\n\n  if (typename &&\n    typename !== 'Object' &&\n    typename !== '[object Object]') {\n    res.type = typename;\n  }\n\n  var fname = site.getFunctionName();\n  if (fname) {\n    res.function = fname;\n  }\n\n  var meth = site.getMethodName();\n  if (meth && fname !== meth) {\n    res.method = meth;\n  }\n\n  return res;\n};\n\nStackUtils.prototype._setFile = function (result, filename) {\n  if (filename) {\n    filename = filename.replace(/\\\\/g, '/');\n    if ((filename.indexOf(this._cwd + '/') === 0)) {\n      filename = filename.substr(this._cwd.length + 1);\n    }\n    result.file = filename;\n  }\n};\n\nvar re = new RegExp(\n  '^' +\n    // Sometimes we strip out the '    at' because it's noisy\n  '(?:\\\\s*at )?' +\n    // $1 = ctor if 'new'\n  '(?:(new) )?' +\n    // $2 = function name (can be literally anything)\n    // May contain method at the end as [as xyz]\n  '(?:(.*?) \\\\()?' +\n    // (eval at <anonymous> (file.js:1:1),\n    // $3 = eval origin\n    // $4:$5:$6 are eval file/line/col, but not normally reported\n  '(?:eval at ([^ ]+) \\\\((.+?):(\\\\d+):(\\\\d+)\\\\), )?' +\n    // file:line:col\n    // $7:$8:$9\n    // $10 = 'native' if native\n  '(?:(.+?):(\\\\d+):(\\\\d+)|(native))' +\n    // maybe close the paren, then end\n    // if $11 is ), then we only allow balanced parens in the filename\n    // any imbalance is placed on the fname.  This is a heuristic, and\n    // bound to be incorrect in some edge cases.  The bet is that\n    // having weird characters in method names is more common than\n    // having weird characters in filenames, which seems reasonable.\n  '(\\\\)?)$'\n);\n\nvar methodRe = /^(.*?) \\[as (.*?)\\]$/;\n\nStackUtils.prototype.parseLine = function parseLine(line) {\n  var match = line && line.match(re);\n  if (!match) {\n    return null;\n  }\n\n  var ctor = match[1] === 'new';\n  var fname = match[2];\n  var evalOrigin = match[3];\n  var evalFile = match[4];\n  var evalLine = Number(match[5]);\n  var evalCol = Number(match[6]);\n  var file = match[7];\n  var lnum = match[8];\n  var col = match[9];\n  var native = match[10] === 'native';\n  var closeParen = match[11] === ')';\n\n  var res = {};\n\n  if (lnum) {\n    res.line = Number(lnum);\n  }\n\n  if (col) {\n    res.column = Number(col);\n  }\n\n  if (closeParen && file) {\n    // make sure parens are balanced\n    // if we have a file like \"asdf) [as foo] (xyz.js\", then odds are\n    // that the fname should be += \" (asdf) [as foo]\" and the file\n    // should be just \"xyz.js\"\n    // walk backwards from the end to find the last unbalanced (\n    var closes = 0;\n    for (var i = file.length - 1; i > 0; i--) {\n      if (file.charAt(i) === ')') {\n        closes ++;\n      } else if (file.charAt(i) === '(' && file.charAt(i - 1) === ' ') {\n        closes --;\n        if (closes === -1 && file.charAt(i - 1) === ' ') {\n          var before = file.substr(0, i - 1);\n          var after = file.substr(i + 1);\n          file = after;\n          fname += ' (' + before;\n          break;\n        }\n      }\n    }\n  }\n\n  if (fname) {\n    var methodMatch = fname.match(methodRe);\n    if (methodMatch) {\n      fname = methodMatch[1];\n      var meth = methodMatch[2];\n    }\n  }\n\n  this._setFile(res, file);\n\n  if (ctor) {\n    res.constructor = true;\n  }\n\n  if (evalOrigin) {\n    res.evalOrigin = evalOrigin;\n    res.evalLine = evalLine;\n    res.evalColumn = evalCol;\n    res.evalFile = evalFile && evalFile.replace(/\\\\/g, '/');\n  }\n\n  if (native) {\n    res.native = true;\n  }\n\n  if (fname) {\n    res.function = fname;\n  }\n\n  if (meth && fname !== meth) {\n    res.method = meth;\n  }\n\n  return res;\n};\n\nvar bound = new StackUtils();\n\nObject.keys(StackUtils.prototype).forEach(function (key) {\n  StackUtils[key] = bound[key].bind(bound);\n});\n"]},"metadata":{},"sourceType":"script"}